import krpc
import time
import math


def wait_for_solid_fuel_empty(vessel, target_pitch, current_pitch):
    """
    Ожидание полного выгорания твердого топлива в твердотопливных ускорителях (SRB).
    
    Функция непрерывно мониторит количество твердого топлива на борту корабля,
    отслеживая его уменьшение до полного истощения. Во время ожидания также 
    продолжается процесс гравитационного разворота, если высота меньше 40 км.
    Это важно для обеспечения оптимальной траектории выведения даже при 
    работающих твердотопливных ускорителях.
    
    Особенности реализации:
    - Использует пороговое значение 0.5 единиц топлива для первичного определения
      окончания работы ускорителей
    - Выполняет финальную проверку с порогом 0.1 единиц для исключения 
      ложных срабатываний из-за колебаний показаний датчиков
    - Продолжает управление тангажом для поддержания оптимальной траектории
    
    Параметры:
        vessel: объект корабля из kRPC, представляющий текущее космическое судно
        target_pitch: целевой угол тангажа, к которому стремится система управления
        current_pitch: текущий угол тангажа корабля
    
    Возвращает:
        True: когда твердое топливо полностью израсходовано
    """
    start_time = time.time()

    LAUNCH_AZIMUTH = 90  # Стандартный азимут запуска (90° = строго на восток)

    while True:
        # Получаем текущее количество твердого топлива на борту
        solid_fuel = vessel.resources.amount('SolidFuel')
        
        # Первичная проверка: если топлива осталось меньше 0.5 единиц
        if solid_fuel <= 0.5:
            # Финальная проверка для исключения ложных срабатываний
            # Некоторые движки могут показывать остаточные значения
            final_check = vessel.resources.amount('SolidFuel')
            if final_check <= 0.1:
                # Твердое топливо действительно израсходовано
                return True

        # Продолжаем гравитационный разворот во время работы ускорителей
        # если высота меньше 40 км и текущий тангаж больше 5 градусов
        if vessel.flight().surface_altitude < 40000 and current_pitch > 5:
            current_alt = vessel.flight().surface_altitude

            # Плавное уменьшение тангажа от 10 км до 40 км
            if current_alt > 10000:
                # Расчет прогресса разворота: 0 на 10 км, 1 на 40 км
                progress = (current_alt - 10000) / (40000 - 10000)
                # Линейная интерполяция угла тангажа
                new_pitch = target_pitch - (target_pitch - 5) * progress

                # Обновляем угол тангажа только если он уменьшился
                if new_pitch < current_pitch:
                    current_pitch = new_pitch
                    vessel.auto_pilot.target_pitch_and_heading(current_pitch, LAUNCH_AZIMUTH)

        time.sleep(0.1)  # Небольшая пауза для снижения нагрузки на CPU


def perform_orbit_circularization(conn, vessel, target_apo, target_peri):
    """
    Выполнение маневра для довыведения на целевую круговую (или эллиптическую) орбиту.
    
    Функция осуществляет сложный орбитальный маневр в апоцентре (самой высокой точке орбиты)
    для изменения формы орбиты с суборбитальной на целевую. Маневр включает:
    1. Расчет требуемого изменения скорости (ΔV) на основе орбитальной механики
    2. Создание узла маневра в расчетной точке
    3. Ориентацию корабля в направлении маневра
    4. Выполнение импульса скорости в точно рассчитанное время
    5. Контроль достижения целевых параметров орбиты
    
    Теоретическая основа:
    - Использует уравнения орбитальной механики для расчета ΔV
    - Применяет формулу орбитальной скорости: v = √(μ * (2/r - 1/a))
      где μ - гравитационный параметр планеты (GM),
      r - текущее расстояние от центра планеты,
      a - большая полуось орбиты
    - Для расчета времени работы двигателя использует уравнение Циолковского
    
    Параметры:
        conn: активное соединение с kRPC для доступа к API игры
        vessel: объект корабля, который необходимо вывести на орбиту
        target_apo: целевая высота апогея в метрах (относительно поверхности планеты)
        target_peri: целевая высота перигея в метрах (относительно поверхности планеты)
    
    Возвращает:
        tuple: (final_apo, final_peri) - достигнутые высоты апогея и перигея после маневра
    """
    # Получаем необходимые потоки данных из kRPC
    space_center = conn.space_center
    ut = space_center.ut  # Вселенское время (Universal Time) в игре
    
    # Получаем геометрические параметры планеты (Кербина в данном случае)
    kerbin_radius = vessel.orbit.body.equatorial_radius
    
    # Получаем текущие орбитальные параметры (относительно поверхности)
    current_apo_val = vessel.orbit.apoapsis_altitude
    current_peri_val = vessel.orbit.periapsis_altitude
        
    # Переводим высоты относительно поверхности в абсолютные расстояния от центра планеты
    # r_abs = r_alt + R_planet (важно для орбитальных расчетов)
    current_apo_abs = current_apo_val + kerbin_radius
    current_peri_abs = current_peri_val + kerbin_radius
    target_apo_abs = target_apo + kerbin_radius
    target_peri_abs = target_peri + kerbin_radius
    
    # Гравитационный параметр планеты (μ = G*M) - константа для каждой планеты
    mu = vessel.orbit.body.gravitational_parameter
    
    # Рассчитываем большие полуоси орбит
    # a = (r_apo + r_peri) / 2 - для эллиптических орбит
    current_sma = vessel.orbit.semi_major_axis  # Текущая большая полуось (может отличаться от расчета)
    target_sma = (target_apo_abs + target_peri_abs) / 2  # Целевая большая полуось
    
    # Расчет требуемого изменения скорости (ΔV) в апоцентре
    # Формула орбитальной скорости в заданной точке: v = √(μ * (2/r - 1/a))
    v_current = math.sqrt(mu * (2 / current_apo_abs - 1 / current_sma))  # Текущая скорость в апоцентре
    v_target = math.sqrt(mu * (2 / current_apo_abs - 1 / target_sma))    # Целевая скорость в апоцентре
    delta_v = v_target - v_current  # Необходимое приращение скорости (ΔV) - может быть отрицательным
    
    # Создаем узел маневра в апоцентре (самой высокой точке орбиты)
    # Маневр в апоцентре наиболее эффективен для поднятия перицентра
    main_node = vessel.control.add_node(
        ut + vessel.orbit.time_to_apoapsis,  # Время выполнения маневра
        prograde=delta_v  # Импульс в направлении движения
    )
    
    # Ориентация корабля на вектор маневра
    # Используем систему отсчета узла маневра для точного направления
    vessel.auto_pilot.reference_frame = main_node.reference_frame
    vessel.auto_pilot.target_direction = (0, 1, 0)  # Направление по вектору скорости (вперед)
    vessel.auto_pilot.engage()  # Включаем автопилот
    vessel.auto_pilot.wait()  # Ждем завершения ориентации
    
    # Расчет времени работы двигателя по формуле Циолковского
    # burn_time = (m0 - m1) / (F / Isp)
    F = vessel.available_thrust  # Доступная тяга двигателя в Ньютонах
    Isp = vessel.specific_impulse * 9.82  # Переводим удельный импульс в м/с² (1 Isp = 9.82 м/с)
    m0 = vessel.mass  # Начальная масса корабля
    
    # m1 = m0 / exp(Δv / Isp) - конечная масса по формуле Циолковского
    m1 = m0 / math.exp(delta_v / Isp)
    flow_rate = F / Isp  # Расход топлива (кг/с)
    burn_time = (m0 - m1) / flow_rate if flow_rate > 0 else 0  # Время работы двигателя

    # Ожидание времени начала маневра (50% времени работы до апоцентра)
    # Это оптимальное время начала импульса для минимизации ошибок
    while vessel.orbit.time_to_apoapsis > burn_time / 2:
        time.sleep(0.5)  # Проверяем каждые 0.5 секунды
    
    # Включаем двигатель на полную тягу
    vessel.control.throttle = 1.0
    
    start_burn_time = time.time()  # Запоминаем время начала маневра
    
    # Выполнение маневра до достижения целевого перигея
    # Контролируем параметры орбиты в реальном времени
    while vessel.orbit.periapsis_altitude < target_peri:
        time.sleep(0.1)  # Частые проверки для точного управления
    
    # Выключаем двигатель после достижения цели
    vessel.control.throttle = 0.0
    vessel.auto_pilot.disengage()  # Отключаем автопилот
    
    # Получаем финальные параметры орбиты для отчетности
    final_apo = vessel.orbit.apoapsis_altitude
    final_peri = vessel.orbit.periapsis_altitude
    
    # Удаляем узел маневра, так как он больше не нужен
    main_node.remove()

    return final_apo, final_peri


def update_active_vessel(conn, current_vessel):
    """
    Проверка и обновление активного корабля после отделения ступеней.
        
    Параметры:
        conn: соединение kRPC для доступа к пространству центра управления
        current_vessel: текущий объект корабля, который мы ожидаем быть активным
    
    Возвращает:
        vessel: актуальный объект активного корабля
    """
    new_vessel = conn.space_center.active_vessel
    if new_vessel.name != current_vessel.name:
        # Активный корабль изменился (произошло отделение)
        return new_vessel
    return current_vessel  # Активный корабль не изменился


def launch_complete_mission():
    """
    Выполнение полного цикла запуска с последующей циркуляризацией орбиты.
    
    Основная функция, которая управляет всем процессом запуска:
    1. Подключение к KSP через kRPC
    2. Подготовка корабля к запуску
    3. Вертикальный подъем на начальную высоту
    4. Гравитационный разворот для выхода на орбитальную траекторию
    5. Управление работой твердотопливных ускорителей
    6. Выведение на суборбитальную траекторию с целевым апогеем
    7. Отделение отработавших ступеней
    8. Развертывание систем (солнечные батареи, антенны)
    9. Циркуляризация орбиты в апоцентре
    10. Завершение миссии с достижением целевой орбиты
    """
    # Подключение к KSP через kRPC
    # Имя соединения отображается в игровом интерфейсе kRPC
    conn = krpc.connect(name='Запуск с автоматической циркуляризацией')
    vessel = conn.space_center.active_vessel  # Получаем текущий активный корабль
    space_center = conn.space_center  # Центр управления для доступа к глобальным функциям
    
    # Включаем систему стабилизации (SAS)
    # SAS помогает стабилизировать корабль и удерживать ориентацию
    vessel.control.sas = True

    # Запуск двигателей: устанавливаем полную тягу
    vessel.control.throttle = 1.0
    time.sleep(3)  # Пауза для выхода двигателей на режим
    vessel.control.activate_next_stage()  # Активируем первую ступень
    
    # Фаза 1: Вертикальный подъём до 1 км
    # Начальный вертикальный подъем необходим для:
    # 1. Набора безопасной высоты над стартовой площадкой
    # 2. Преодоления плотных слоев атмосферы с минимальными аэродинамическими потерями
    while vessel.flight().surface_altitude < 1000:
        time.sleep(0.1)  # Быстрый опрос для своевременного перехода к следующей фазе
    
    # Выключаем SAS для перехода к ручному управлению через автопилот
    # SAS мешает плавному гравитационному развороту
    vessel.control.sas = False
    
    # Устанавливаем азимут запуска
    # 90° = строго на восток - оптимально для использования вращения Кербина
    # (Кербин вращается с востока на запад, запуск на восток дает дополнительную скорость)
    LAUNCH_AZIMUTH = 90
    
    vessel.auto_pilot.engage()  # Включаем автопилот kRPC
    
    # Начальный угол тангажа (85° от горизонта)
    # Почти вертикальный, но с небольшим наклоном для начала разворота
    initial_pitch = 85
    vessel.auto_pilot.target_pitch_and_heading(initial_pitch, LAUNCH_AZIMUTH)
    
    current_pitch = initial_pitch  # Текущий угол для отслеживания
    target_pitch = 45  # Целевой угол после завершения первой фазы разворота
    
    # Фаза 2: Гравитационный разворот от 1 до 10 км
    # Плавное уменьшение угла тангажа от 85° до 45° пропорционально высоте
    # Это позволяет оптимально набирать горизонтальную скорость
    while vessel.flight().surface_altitude < 10000:
        current_alt = vessel.flight().surface_altitude
        
        # Плавное уменьшение угла тангажа с высотой
        if current_alt > 1000:
            # Расчет прогресса разворота: 0 на 1 км, 1 на 10 км
            progress = (current_alt - 1000) / (10000 - 1000)
            # Линейная интерполяция между начальным и целевым углом
            new_pitch = initial_pitch - (initial_pitch - target_pitch) * progress
            
            # Обновляем угол тангажа только если он уменьшился
            if new_pitch < current_pitch:
                current_pitch = new_pitch
                vessel.auto_pilot.target_pitch_and_heading(current_pitch, LAUNCH_AZIMUTH)
        
        time.sleep(0.1)
    
    # Ожидание выгорания твердого топлива (если есть твердотопливные ускорители)
    # Эта функция также продолжает гравитационный разворот во время работы SRB
    wait_for_solid_fuel_empty(vessel, current_pitch, target_pitch)
    
    # Перезапуск жидкостных двигателей (если они были выключены)
    # Некоторые конструкции ракет имеют возможность отключения ЖРД при работе SRB
    vessel.control.throttle = 0.0
    time.sleep(2)  # Пауза для стабилизации
    vessel.control.activate_next_stage()  # Активируем следующую ступень (если нужно)
    time.sleep(2)  # Пауза перед включением тяги
    vessel.control.throttle = 1.0  # Полная тяга ЖРД
    
    # Фаза 3: Продолжение разворота до почти горизонтального полета (5°)
    # Дальнейшее уменьшение тангажа для выхода на орбитальную траекторию
    while vessel.flight().surface_altitude < 40000 and current_pitch > 5:
        current_alt = vessel.flight().surface_altitude
        
        if current_alt > 10000:
            # Прогресс от 10 км до 40 км
            progress = (current_alt - 10000) / (40000 - 10000)
            # Линейная интерполяция от 45° до 5°
            new_pitch = target_pitch - (target_pitch - 5) * progress
            
            if new_pitch < current_pitch:
                current_pitch = new_pitch
                vessel.auto_pilot.target_pitch_and_heading(current_pitch, LAUNCH_AZIMUTH)
        
        time.sleep(0.1)
    
    # Устанавливаем почти горизонтальный полёт (1°)
    # На этой высоте атмосфера достаточно разрежена для горизонтального полета
    vessel.auto_pilot.target_pitch_and_heading(1, LAUNCH_AZIMUTH)
    
    # Контролируем апогей и выключаем двигатель при достижении цели
    # Это критически важно для выведения на правильную суборбитальную траекторию
    target_apo_max = 220000  # Максимальный апогей (220 км)
    
    while True:
        # Получаем текущий апогей (проекцию самой высокой точки орбиты)
        current_apo = vessel.orbit.apoapsis_altitude
      
        # Если апогей достиг или превысил целевую высоту
        if current_apo >= target_apo_max:
            vessel.control.throttle = 0.0  # Выключаем двигатель
            break  # Завершаем активный участок выведения
        
        time.sleep(0.1)  # Частый опрос для точного контроля
    
    vessel.auto_pilot.disengage()  # Отключаем автопилот
    time.sleep(2)  # Пауза для стабилизации
    
    # Отделение отработавших ступеней
    # Этот процесс может включать несколько стадий разделения
    vessel = update_active_vessel(conn, vessel)  # Обновляем объект корабля
    control = vessel.control  # Получаем объект управления текущего корабля
    
    # Несколько циклов отделения (обычно 3: обтекатели, первая ступень, вторая ступень)
    for i in range(3):
        control.activate_next_stage()  # Активируем разделители или следующую ступень
        time.sleep(2)  # Пауза для завершения процесса отделения
        vessel = update_active_vessel(conn, vessel)  # Проверяем, не изменился ли активный корабль
        control = vessel.control  # Обновляем объект управления
    
    # Включение систем через action group 1
    # Обычно это солнечные батареи, антенны, научные приборы
    vessel.control.toggle_action_group(1)
    time.sleep(0.5)  # Короткая пауза
    vessel = conn.space_center.active_vessel  # Финальное обновление объекта корабля
    
    # Выключаем двигатель для подготовки к маневру циркуляризации
    # (на всякий случай, если двигатель был случайно включен)
    vessel.control.throttle = 0.0
    time.sleep(1)  # Пауза для уверенности
    
    # Целевые параметры орбиты
    target_apo = 220000  # 220 км - целевая высота апогея
    target_peri = 170000  # 170 км - целевая высота перигея
    
    # Выполнение маневра циркуляризации орбиты
    final_apo, final_peri = perform_orbit_circularization(conn, vessel, target_apo, target_peri)


if __name__ == '__main__':
    """
    Точка входа в программу при прямом запуске скрипта.
    """
    launch_complete_mission()